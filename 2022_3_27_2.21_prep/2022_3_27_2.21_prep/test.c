#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>

/*
预处理：相当于根据预处理指令组装新的C/C++程序。经过预处理，
会产生一个没有头文件（都已经被展开了）、宏定义（都已经替换了），
没有条件编译指令（该屏蔽的都屏蔽掉了），没有特殊符号的输出文件，
这个文件的含义同原本的文件无异，只是内容上有所不同。

编译：将预处理完的文件逐一进行一系列词法分析、语法分析、语义分析及优化后，
产生相应的汇编代码文件。编译是针对单个文件编译的，只校验本文件的语法是否有问题，
不负责寻找实体。

链接：通过链接器将一个个目标文件（或许还会有库文件）
链接在一起生成一个完整的可执行程序。 链接程序的主要工作就是将有关的目标文件彼此相连接，
也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，
使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。
在此过程中会发现被调用的函数未被定义。需要注意的是，
链接阶段只会链接调用了的函数/全局变量，
如果存在一个不存在实体的声明（函数声明、全局变量的外部声明），但没有被调用，
依然是可以正常编译执行的。
*/

#define SwapIntBit(n) (((n) & 0x5555555555555555) << 1 | ((n) & 0xaaaaaaaaaaaaaaaa) >> 1)
#define num 12
/*
* 交换奇偶位，需要先分别拿出奇偶位。既然是宏，分别拿出用循环不是很现实，
那就用&这些位的方式来做。奇数位拿出，那就是要&上010101010101……，
偶数位拿出，就是要&上101010101010……，对应十六进制分别是555……和aaa……，
一般我们默认是32位整数，4位对应一位16进制就是8个5，8个a。
通过& 0x55555555的方式拿出奇数位和& 0xaaaaaaa的方式拿出偶数位。
奇数位左移一位就到了偶数位上，偶数位右移一位就到了奇数位上，
最后两个数字或起来，就完成了交换。

※这个宏只能完成32位以内的整形，要想完成64位的，那就将5和a的数量翻倍即可。
*/

//int main()
//{
//	int n = num;
//	printf("%d\n", n);
//	//char s[10];
//	//_itoa(n, s, 2);
//	//printf("%s\n", s);
//	SwapIntBit(n);
//	//_itoa(n, s, 2);
//	//printf("%s\n", s);
//	printf("%d\n", n);
//	return 0;
//}


//找单身狗
//
//例如 1 1 2 2 3 5
//
//1.通过0对自身依次异或，得到的就是两个单独数异或的结果，即 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 5 = 3 ^ 5 = 6 = 110
//
//2.找到异或后结果的二进制序列，找出为1的位数（如果为1，则说明两个单独数在这个位不相同，可凭此将两个数分离）, 我们可以发现在第二位和第三都是1，其实取哪一位都可以，目的是分离这两个数，这里我们取第二位
//
//3.找到位数后，将按其他数的这个位数是否为1，还是为0分离，这就形成了两组数，各带一个单独数。
//分离的两组数为 1 1 5和2 2 3
//
//4.对这两组数通过0对自身依次异或，即得到的就是两个单独数。

int main()
{
	int arr[] = { 1,2,3,4,5,1,2,3,4,6};
	
	int ret = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		//先异或
		//通过0对自身依次异或，
		//将两个单独的数的异或后的结果找出，再通过结果将两个值分离开来
		ret ^= arr[i];
	}

	//找到异或后结果的二进制序列，找出为1的位数（如果为1，
	//则说明两个单独数在这个位不相同，可凭此将两个数分离）
	int pos = 0;
	for (i = 0; i < 32; i++)
	{
		if (((ret >> i) & 1) == 1)
		{
			pos = i;
			break;
		}
	}
	//按照第pos位为0或1来分组
	int n = 0;
	int m = 0;
	for (i = 0; i < sz; i++)
	{
		if (((arr[i] >> pos) & 1) == 1)
		{
			n ^= arr[i];
		}
	}

	m = ret ^ n;
	printf("%d %d\n", n, m);

	return 0;
}