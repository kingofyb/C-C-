#include<iostream>
#include<vector>
using namespace std;

int main()
{

	return 0;
}

/*
162. 寻找峰值

https://leetcode.cn/problems/find-peak-element/description/

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，
在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。


示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。

示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5
解释：你的函数可以返回索引 1，其峰值元素为 2；
	 或者返回索引 5， 其峰值元素为 6。

对于所有有效的 i 都有 nums[i] != nums[i + 1]

解法一：暴力解法
从第一个位置一直向后走，然后分情况即可
1. 第二个元素就往下降，那么第一个元素就是峰顶

2. 一直遍历，直到找到下一个元素比前一个元素小

3. 一直遍历没发现下一个元素比前一个元素小，这时返回最后一个元素

时间复杂度：O(N)

解法二：优化暴力解法 - 二分查找
            i i+1
------------*-*-----------

1. arr[i] > arr[i+1] 
那么此时是一个下降趋势，那么在左边区间一定存在一个峰值，一定存在最终结果
右边不一定，接下来在左边寻找

2. arr[i] < arr[i+1]
那么此时是一个上升趋势，那么在右边区间一定存在一个峰值
左边不一定，接下来在右边寻找

此时发现二段性，可以把数组分成两部分

第一种情况：arr[mid] > arr[mid+1] -> right = mid(包含i，i也可能是峰值)

第二种情况：arr[mid] < arr[mid+1] -> left = mid + 1
*/

//class Solution {
//public:
//    int findPeakElement(vector<int>& nums) {
//        int left = 0, right = nums.size() - 1;
//        while (left < right)
//        {
//            int mid = left + (right - left) / 2;
//            if (nums[mid] > nums[mid + 1]) right = mid;
//            else left = mid + 1;
//        }
//        return left;
//    }
//};

/*
153. 寻找旋转排序数组中的最小值

https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。
例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 
旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 *互不相同* 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。
请你找出并返回数组中的 *最小元素* 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。

示例 3：

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

解法一：暴力查找最小值
[3,4,5,1,2]
从前往后遍历即可

时间复杂度：O(N)
[3,4,5,1,2]
可以分解为两段，一段有上升趋势，峰值过后的那一段也是上升趋势

解法二：二分查找

二段性：
          B
         /
        /
       /
     A
--------------------------------------------------------
                            D
                           /
                          /
                         /
                        C

AB这段区域是严格大于D点这个值的
CD这段区域是严格小于等于D点这个值的

1. AB这段区域: nums[i] > nums[n-1]
2. CD这段区域: nums[i] <= nums[n-1]

如果是第一种情况：nums[mid] > nums[n-1] -> left = mid + 1
当落在AB的时候没有要找的结果，所以要到右边去找

如果是第二种情况：nums[mid] <= nums[n-1] -> right = mid
mid落在CD，去左边区域寻找，但是right不能越过C点

最后会停在c点，c点就是最小值
*/

//class Solution {
//public:
//    int findMin(vector<int>& nums) {
//        int left = 0, right = nums.size() - 1;
//        int x = nums[right];
//        while (left < right)
//        {
//            int mid = left + (right - left) / 2;
//            if (nums[mid] > x) left = mid + 1;
//            else right = mid;
//        }
//        return nums[left];
//    }
//};

/*
剑指 offer 53 - II：0～n-1中缺失的数字
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。
在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:
输入: [0,1,3]
输出: 2

示例 2:
输入: [0,1,2,3,4,5,6,7,9]
输出: 8

限制：
1 <= 数组长度 <= 10000

解法一：哈希表

解法二：直接遍历找结果

解法三：位运算
用^异或运算
比如[0, 1, 2, 4, 5, 6]
[0, 1, 2, 3, 4, 5, 6]
拿正常数组的数和没有缺少的数组通通异或在一起，相同的数会抵消，最后异或的结果就是缺少的数

解法四：高斯求和公式 - 等差数列
算一下没有缺少这批数的和，首项+末项的和/2
然后依次减去数组中的数，最后的数就是缺失的数

上方四组的时间复杂度都是O(N)

更优的解法，解法五：二分查找
[0, 1, 2, | 4, 5, 6]
index:
[0, 1, 2, | 3, 4, 5]

|左边的值一一对应，右边不对应
所以有二段性

要找的结果就是右边区域的最左边的元素的下标

1. 落在左边区间，值和下标对应：nums[mid] = mid -> left = mid + 1
去右边寻找，因为这个区域一定没有结果

2. 落在右边区间：nums[mid] != mid -> right = mid

细节问题：边界情况
如果数组是[0, 1, 2, 3]，下标也是一样的
缺失的元素是后面的4，现在根本不存在右边的区间
最终返回的时候要判断一下，当 left==right，所指的值跟下标相等，要返回的是+1
*/

int missingNumber(vector<int>& nums)
{
    // 解法五，二分查找
    int left = 0, right = nums.size() - 1;
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        if (nums[mid] == mid) return left = mid + 1;
        else right = mid;
    }
    // 返回结果，处理细节问题
    return nums[left] == left ? left + 1 : left;

}