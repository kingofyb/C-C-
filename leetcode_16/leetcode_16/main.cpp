#include<iostream>
using namespace std;

int main()
{
	int a = 1; // 0001
	int b = 2; // 0010
	int c = a ^ b; // 0011
	cout << c << endl; // 3
	return 0;
}

// 191. 位1的个数
/*
https://leetcode.cn/problems/number-of-1-bits/

编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中
设置位的个数（也被称为汉明重量）。

输入：n = 11
输出：3
解释：输入的二进制串 1011 中，共有 3 个设置位

左移一直判断，如果为1则ret++
*/

//class Solution {
//public:
//    int hammingWeight(uint32_t n) {
//        int ret = 0;
//        for (int i = 0; i < 32; i++)
//        {
//            if ((n >> i) & 1)
//            {
//                ret++;
//            }
//        }
//        return ret;
//    }
//};


// 461. 汉明距离

/*
https://leetcode.cn/problems/counting-bits/

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

示例 1：

输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10

338. 比特位计数

定义数组：
我们需要一个数组 bits 来存储从 0 到 n 每个数的二进制中 1 的个数。数组的索引即代表相应的数字，数组的值代表该数字的二进制表示中 1 的个数。

初始化条件：
我们知道 0 的二进制中没有 1，所以 bits[0] = 0。

递推公式：
通过观察可以发现，如果我们知道某个数 x 除以 2 后的值的二进制中 1 的个数，那么可以推导出 x 的二进制中 1 的个数。递推公式为：

bits[x] = bits[x >> 1] + (x & 1)

x >> 1：表示将 x 右移一位，即去掉 x 的最低位。
x & 1：表示 x 的最低位是否为 1，如果为 1 则加 1。

计算过程：
对于每个从 1 到 n 的数字，我们按照上述公式一步步计算 bits[i] 的值。


n = 5
初始化：bits = [0, 0, 0, 0, 0, 0] (长度为 6)
从 1 到 5，逐步计算每个数字二进制中 1 的个数。

i = 1：二进制：1
计算：bits[1 >> 1] + (1 & 1) -> bits[0] + 1 = 0 + 1 = 1
更新数组：bits = [0, 1, 0, 0, 0, 0]

i = 2：二进制：10
计算：bits[2 >> 1] + (2 & 1) -> bits[1] + 0 = 1 + 0 = 1
更新数组：bits = [0, 1, 1, 0, 0, 0]

i = 3：二进制：11
计算：bits[3 >> 1] + (3 & 1) -> bits[1] + 1 = 1 + 1 = 2
更新数组：bits = [0, 1, 1, 2, 0, 0]

i = 4：二进制：100
计算：bits[4 >> 1] + (4 & 1) -> bits[2] + 0 = 1 + 0 = 1
更新数组：bits = [0, 1, 1, 2, 1, 0]

i = 5：二进制：101
计算：bits[5 >> 1] + (5 & 1) -> bits[2] + 1 = 1 + 1 = 2
更新数组：bits = [0, 1, 1, 2, 1, 2]

输出：[0, 1, 1, 2, 1, 2]
*/


// 暴力
//for (int i = 0; i <= n; i++)
//{
//    int cur = i;
//    int cnt = 0;
//    while (cur)
//    {
//        if (cur & 1) cnt++;
//        cur = cur >> 1;
//
//    }
//    ret[i] = cnt;
//
//}
//return ret;
//
//    }


// 动态规划
//class Solution {
//public:
//    vector<int> countBits(int n) {
//        // 2 -> [0,1,2] -> [0000,0001,0010] -> [0,1,1]
//        // 5 -> [0,1,2,3,4,5] -> [0000,0001,0010,0011,0100,0101] -> [0,1,1,2,1,2]
//        vector<int> ret(n + 1);
//        for (int i = 0; i <= n; i++)
//        {
//            ret[i] = ret[i >> 1] + (i & 1);
//        }
//        return ret;
//
//    }
//};



// 461. 汉明距离
/*
https://leetcode.cn/problems/hamming-distance/description/

两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

示例 1：
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
	   ↑  ↑
上面的箭头指出了对应二进制位不同的位置。

具体地，记 s=x⊕y，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，
这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。
这样计数器中就累计了 s 的二进制表示中 1 的数量。


*/

//class Solution {
//public:
//    int hammingDistance(int x, int y) {
//        // return __builtin_popcount(x^y);
//        int s = x ^ y, ret = 0;
//        while (s)
//        {
//            ret += s & 1;
//            s >>= 1;
//        }
//        return ret;
//    }
//};

// 136. 只出现一次的数字

/*
https://leetcode.cn/problems/single-number/description/

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

示例 1 ：
输入：nums = [2,2,1]
输出：1

示例 2 ：
输入：nums = [4,1,2,1,2]
输出：4

任何数和 0 做异或运算，结果仍然是原来的数，即 a^0=a。
任何数和其自身做异或运算，结果是 0，即 a^a=0。
异或运算满足交换律和结合律，即 a^b^a=b^a^a=b^(a^a)=b^0=b。

假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。令 a1、a2、...、am为出现两次的 m 个数，am+1
​为出现一次的数。根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：
(a1^a1)^(a2^a2 )^...^(am^am)^am+1
​

根据性质 2 和性质 1，上式可化简和计算得到如下结果：
0^0^...^0^am+1=am+1
​

因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字

*/

//class Solution {
//public:
//	int singleNumber(vector<int>& nums) {
//		int ret = 0;
//		for (auto i : nums) ret ^= i;
//		return ret;
//	}
//};

// 260. 只出现一次的数字 III

/*
给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

示例 1：
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。

示例 2：
输入：nums = [-1,0]
输出：[-1,0]

示例 3：
输入：nums = [0,1]
输出：[1,0]

我们可以使用一个哈希映射统计数组中每一个元素出现的次数。

在统计完成后，我们对哈希映射进行遍历，将所有只出现了一次的数放入答案中。
*/

/*
* class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        unordered_map<int, int> freq;
        for(int num: nums)
        {
            ++freq[num];
        }
        vector<int> ans;
        for(const auto& [num, occ]: freq)
        {
            if(occ == 1)
            {
                ans.push_back(num);
            }
        }
        return ans;
    }
};
*/