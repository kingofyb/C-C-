// 面试题 01.01. 判定字符是否唯一

/*
https://leetcode.cn/problems/is-unique-lcci/description/

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
s[i]仅包含小写字母

示例 1：
输入: s = "leetcode"
输出: false

示例 2：
输入: s = "abc"
输出: true


解法一：哈希表
遍历一遍，把每个字符都放入哈希表中，然后如果有重复就return false
只需要创建一个大小为26的数组即可
比如 [a,b,c,a,d,e,f]

0下标对应a，1下标对应b，然后让里面0或1表示是否出现

时间复杂度：O(N)
空间复杂度：O(N)

解法二：位图
int变量有32位
[              ]
[31,...,3,2,1,0]
            b a
可以让0号位的bit位代表a,1号位代表b,...
bit位里面要么是0，要么是1
可以让0表示这个字符没有出现过，bit位如果是1的话就表示出现过

优化：
鸽巢原理 - 抽屉原理
因为一共有26个英文字母，当字符串长度len如果大于26的时候就一定有重复的
*/

/*

class Solution {
public:
    bool isUnique(string astr)
    {
        // 利用鸽巢原理来做的优化
        if(astr.size() > 26) return false;

        int bitMap = 0;
        for(auto ch : astr)
        {
            // 这一步将字符从'a'到'z'转换为从0到25之间的整数。
            // 这是因为'a'的ASCII值减去'a'的ASCII值为0，'b'减去'a'为1，依此类推。
            int i = ch - 'a';

            // 先判断字符是否已经存在位图里面
            // 右移并判断是否为1
            // 这里我们通过位操作检查这个字符是否已经出现过。位移操作bitMap >> i会将位图向右移i位，将我们关心的位移到最低有效位上。
            // & 1用于检测该位是否为1。如果为1，表示这个字符之前已经出现过，因此返回false
            if(((bitMap >> i) & 1) == 1) return false;
            // 把当前字符加入到位图中，就是把这一位修改成1
            // 这一步将当前字符的位设置为1。1 << i表示将数字1向左移i位，生成一个只有第i位为1，其他位为0的整数。
            // 然后通过|= 操作，将这个值与bitMap进行按位或运算，从而将对应的位设置为1。
            bitMap |= 1 << i;
        }
        return true;
    }
};

*/

// 268. 丢失的数字

/*
https://leetcode.cn/problems/missing-number/description/

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

示例 1：
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。

示例 2：
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。

示例 3：
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。

示例 4：
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。

解法一：哈希表
创建一个大小为n+1的数组，把出现的数字都标记一下比如设为1，然后遍历，哪个数字没有标记，就是哪个数字缺失

解法二：高斯求和
求出原本的和，然后减去数组的和，结果就是缺失的数字

解法三：位运算（异或运算的运算律）
比如给定的数组是[0,1,3,5,4]
实际的应该是[0,1,2,3,4,5]

把这一堆数全部异或在一起，最终结果就是缺失的数
*/

/*
class Solution {
public:
    int missingNumber(vector<int>& nums)
    {
        // 位运算
        int ret = 0;
        // 先把整个数组异或在一起
        for(auto x : nums) ret ^= x;
        for(int i=0; i<=nums.size(); i++) ret ^= i;

        return ret;

        // 高斯求和
    //     int act = 0;
    //     int n = nums.size();
    //     int sum = n*(n+1) / 2;
    //     for(int i=0; i<n; i++)
    //     {
    //         act += nums[i];
    //     }
    //     return sum - act;
    }
};

*/

// 371. 两整数之和

/*
https://leetcode.cn/problems/sum-of-two-integers/description/


给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。

示例 1：
输入：a = 1, b = 2
输出：3

示例 2：
输入：a = 2, b = 3
输出：5

笔试：不讲武德，直接 return a+b

解法一：位运算(异或运算 - 无进位相加)
比如13 + 28 = 41 a = 13, b = 28
a:   0 0 1 1 0 1
b:   0 1 1 1 0 0

a^b - 这个是无进位相加
     0 1 0 0 0 1 -- (x)
要找到进位
只有1+1才会进位，0+1或者1+0进位都是0 - 这个正好就是按位与& - 有0就是0，两个1就是1

----------------------------------------------------------------------------------------
进位：

(a&b) << 1，应该是算完之后左移1才有进位
     0 1 1 0 0 0 -- (y)

----------------------------------------------------------------------------------------
然后继续重复上面的操作
     0 1 0 0 0 1 -- (x)
     0 1 1 0 0 0 -- (y)

x^y: 0 0 1 0 0 1 -- (e)

(x&y) << 1:
     1 0 0 0 0 0 -- (f)

----------------------------------------------------------------------------------------
然后继续重复上面的操作
e^f: 1 0 1 0 0 1 

(e&f) << 1:
     0 0 0 0 0 0

当进位变为0就结束


*/

/*
class Solution {
public:
    int getSum(int a, int b)
    {
        while(b != 0)
        {
            // x表示无进位相加的结果
            int x = a^b;
            // 进位
            unsigned int carry = (unsigned int)(a&b) << 1;

            a = x;
            b = carry;
        }
        return a;
    }
};

*/